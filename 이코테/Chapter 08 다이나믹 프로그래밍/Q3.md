# 실전 문제 3 : 효율적인 화폐 구성
# 문제 설명
N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다. 
이때 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다.
예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수이다.

<br>

# 입력 조건
- 첫째 줄에  N, M이 주어진다. (1 <= N <= 100, 1 <= M <= 10,000)
- N개의 줄에는 각 화폐의 가치가 주어진다. 화폐가치는 10,000보다 작거나 같은 자연수이다.


<br>

# 출력 조건
- 첫째 줄에 M원을 만들기 위한 최소한의 화폐 개수를 출력한다.
- 불가능할 때는 -1을 출력한다.

<br>

# 입력 예시

```
2 15
2
3
```

<br>

# 출력 예시

```
5
```

<br>

# 코드

```java
public class Main {
    public static void main(String[] args) {
        int n = 2;
        int m = 15;
        int[] arr = {2, 3};

        int[] dp = new int[m + 1];
        Arrays.fill(dp, 10001); // 만들 수 있는 화폐 가치보다 큰 값으로 초기화
        dp[0] = 0;

        for (int i = 0; i < n; i++) {
            for (int j = arr[i] != 10001) {
                if (dp[j - arr[i]] != 10001) {
                    dp[j] = Math.min(dp[j], dp[j - arr[i]] + 1);
                }
            }
        }

        if (dp[m] == 10001) {
            System.out.println(-1);
        } else {
            System.out.println(dp[m]);
        }
    }
}
```
dp 배열의 각 인덱스를 화폐로 여기고, 각 인덱스마다 특정 금액을 만들 수 있는 화폐 구성(개수)을 저장한다. 따라서, `N x M` 의 시간 복잡도가 나오게 된다.  
최종적으로, `dp[m]`에 m을 만들기 위해 필요한 화폐의 개수가 저장된다.